## 1. 레디스를 많이 사용하는 곳

1. 캐시가 필요한 곳
2. 인메모리 디비로 사용하는 곳
3. 랭킹 저장용
4. job queue
5. access token 저장 store
6. rate limit 요청수 제한

## 2. 캐시

같은 요청에 대해서 같은 결과를제공할 때 결과를 계산해 두었다가 재요청이 들어오면 재계산 없이 바로 결과를 돌려준다.

리소스 별로 오른쪽으로 갈수록 속도는 빠르지만 용량이 작고 비싸다. (Disk → Memori → L3 cache → L2 cache → L1 cache → core)

### 인메모리의 장단점

#### 장점 

1. 접근속도가 빠르다. 다른 스토리지(SSD, HSS)를 쓰는 것보다 속도가 빠르다.

#### 잔점 

1. 다른 스토리지보다 크기가 작으면서 비싸다.

### 파레토의 법칙 8:2 법칙

80퍼센트의 행동이 전체의 20프로의 결과이고, 20퍼센트의 행동이 전체의 80의 결과이다..?

80퍼센트의 활동을 20프로의 유저가 하기 때문에 20프로의 데이터를 캐시하면 서비스 대부분의 데이터를 커버할 수 있다.

### 캐시가 유용한 케이스

1. 적은 데이터가 빈번하게 접근될 때 유용하다.
    1. 캐시를 해도 되는 API 인지 
        1. 읽기용이 캐시하기 유리하다.
    2. key를 어떻게 정의할 것이지
        1. key는 유일해야한다. 유저 아이디나.. 특정 기간의 파라미터도 포함될 수 있다.
        2. prefix를 보통 붙인다 
    3. value는 어떻게 정의할 것인지 고민이 필요하다.
        1. 응답 결과를 그대로 저장하거나 새로운 응답을 구성해서 저장한다.
        2. 피드(빈도)를 추가하고 sorted set을 사용할 수도 있다.

![Untitled](https://github.com/goyanglee/study_redis/blob/main/Chapter%203.%20%EB%8C%80%EA%B7%9C%EB%AA%A8%20%ED%8A%B8%EB%9E%98%ED%94%BD%20%EC%B2%98%EB%A6%AC%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Redis/image/3_2_1.png)

#### 사용 예: Access Token

1. 서비스에서 매번 로그인하는 것을 피하기 위해 저장
2. 유저정보는 DB에 저장
3. JWT는 해당 키가 유효한지 여부만 저장하고 유저정보는 JWT안에 저장하는 경우가 많음 
4. key는 token, value는 user 정보, 유효기간 저장  

#### 사용 예: Rate Limit

1. 오픈 API 나 특정 API 를 제공하는 서비스의 경우 시간당 몇 회 호출 등의 제한을 걸어 두는데 이를 구현하는데도 레디스가 많이 사용된다.
    1. key에 API 종류, userId, 특정 기간으로 조합 api:maps:1234:20201001111
    2. value에 호출 회수

## 3. AWS ElastiCache

AWS의 레디스 서비스. 여기에서 기본 레디스의 명령어 중에 쓰지 못하는 명령어들이 있다.

## 4. 대규모 서비스에서의 캐시

1. 여러 캐시 서버를 둔다.
2. 샤딩 또는 Consistent Hashing을 통해서 데이터를 저장한다.

## 5. 고민

1. 평소 서버 대수를 몇 대를 둬야할까?
2. 피크 타임은 언제일까?
3. —

---

## Rate Limit 실습

 n 분 동안 k 회만 API 호출하도록 제약 

1. cd ~/the_red/chapter_3/api_limit
2. docker-compose up -d
3. ./start.sh {ip}:7001 
4. http://{ip}:7001/api/v1/scrap/?uid=1000&url=https://fastcampus.co.kr 로 10번 호출하면 초과됐다는 예외 메시지 발생
