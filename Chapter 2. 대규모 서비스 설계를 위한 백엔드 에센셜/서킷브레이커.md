# 서킷브레이커 (회로차단기)

한 화면을 구성하는데 수백 건의 API 호출이 발생한다. 

이 중 하나라도 실패났을 경우, 실패난 부분만 차단해서 보여주는 것이 좋다. (전체장애로 이어지는 것을 차단)

```
서비스에 장애가 났을 때, 실패하는 API를 호출하게 되면, 타임아웃이 날 때까지 대기하는 시간이 소요되고 전체적으로 느려지는 문제가 발생한다. 

[정상호출시]
- 스레드1개라고 가정
- API 타임아웃은 300ms
- 평소에는 20ms에 처리가 됨
- 정상 호출 시에 1스레드는 1초에 50개정도의 API를 처리할 수 있다. 

[장애 시 호출]
- 스레드1개가정
- API 타임아웃은 300ms
- 평소에 20ms 처리
- 장애가 나면 1스레드가 1초에 3개 밖에 처리를 못함
```

<br/>

#### 컨셉 : 타임아웃이 발생하는 API가 빨리 리턴이 된다면 다시 처리속도가 빨라진다. 

*장애의 연쇄 반응 

- A 서비스에 장애가 날 경우 여기에 의존하는 B 서비스도 점점 느려진다.
- B 서비스에 의존하는 C,D,E 서비스도 결국은 느려지게 된다. 
- A를 의존하는 건 B 뿐인데 C, D, E까지 느려지는 문제

장애를 빠르게 차단하는 것이 필요하다. 

<br/>

#### 필수적인API와 필수적이지 않은 API를 구분해야한다!

- 서비스 기준에 따라서 모두 달라질 수 있다. 
- 커머스에서 상품 리스트를 보여줄 수 없다면 큰 문제가 발생한다.
- 그러나 일부 카테고리만 안 보인다면 그냥 넘어가도 되지 않을까?

<br/>

필수적이지 않은 API에서 오류가 발생했을 때, 이를 어떻게 처리해야 서비스에 영향을 낮출 수 있을까?

를 고민하고 나온 것이 서킷브레이커

- <b>Fast Fail Back</b> (빠르게 실패처리)
  - 타임아웃이 300ms여도 호출하자마자 실패처리해준다.
  - 정상적이지 않으면 타임아웃 등으로 처리량이 줄어들고 부하가 늘어날 수 있다. 정상적이지 않다면 최대한 빨리 실패하자. 
  - 예를 들어, 추천서비스가 장애가 나서 실패한다면 기본적으로 미리 정의한 동작을 한다. 추천 서비스 장애 시, 기본적인 순서로 그냥 카탈로그 서비스에 나온 정보를 보여준다. 

<br/>

### 서킷브레이커 상태

1) Closed : 정상적인 API 호출이 되는 상태

2) Open : 일정시간 동안 API 호출을 바로 실패하는 상태

3) Half Open : Open 인 상태에서 일정 시간이 지나면 상태를 다시 확인하기 위해서 API 호출을 시도해보는 상태. Half Open에서 성공하면 Closed로, 실패하면 다시 Open으로 이동한다. 

<br/>

### 서킷브레이커 구현체

Python 

 - Pybreaker(구식)
 - Aiobreaker (asyncio 지원)

Java

- Hystrix (Netflix, 더 이상 업데이트 안 됨)
- Resilience4j (현재 많이 사용중)
