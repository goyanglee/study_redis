# 서비스 디스커버리

로드밸런서/서버/서비스 등이 추가되거나 삭제될 수 있다. 이런 경우에 다른 서비스들을 어떻게 찾을 수 있을까?



### DNS를 통해 서버 목록을 제공할 수 있다

- DNS (= Domain Name Service)
  - IP를 더 쉬운 문자 형태로 제공하는 것

```
Domain: www.fastcampus.co.kr
IP: 35.244.250.204

www.fastcampus.co.kr을 DNS 질의를 하면 하나의 IP만 나온다. 
패스트캠퍼스가 한대의 서버만 운영한다는 의미가 아니며 / 해당 IP는 외부에서 바라보는 로드밸런서의 주소이고 그 뒤로 많은 서버가 존재한다. 
```

<br/>

- 외부 DNS를 통해 클라이언트들은 어느 서버로 가야하는 지 알 수 있고 / 내부 DNS를 통해서 내부 어느 서버로 가야하는 지 알 수 있다. 

- DNS로 서버 목록을 제공하는 것의 단점

  - 외부에서 DNS 목록을 통해 우리 서버 주소를 알 수 있지만

  - 해당 DNS 서버가 죽는다면?

    - DNS TTL 이슈 존재 : 설정된 TTL동안 클라이언트는 잘못된 서버에 호출을 날리게 된다. 

      ```
      DNS 서버도 부하를 많이 받는 서버 중 하나로, 유저들이 접속할 때마다 DNS에 IP를 묻고 그 후에 서버에 접속할 수 있다.
      이 때 클라이언트에서 한번 가져간 데이터는 일정시간동안(TTL) 서버에게 요청하지 않는다. (클라이언트 ~> 서버 호출 X)
      TTL이 1분으로 설정된 DNS 서버가 죽으면, 1분동안 클라이언트는 계속 잘못된 주소로 접속을 시도하게 된다. 
      ```

  - DNS 서비스의 단점을 해결할 수 있는 방법이 <b>"서비스 디스커버리"</b>

    - 서비스의 주소, 포트, 프로토콜 등을 알려주는 방법

      ```
      (참고) 로드밸런서와 서비스디스커버리의 차이
      - 로드밸런서 : 요청(부하)을 어떻게 나눠줄 지에 포인트
      - 서비스디스커버리 : 어떤 서비스가 있고 해당 서비스에 어떤 서버나 앤드포인트들이 있는 지를 찾는 것에 포인트
      ```

<br/>



## 서비스 디스커버리

"한 서비스에서 다른 서버 목록을 어떻게 찾을 것인가?"

예) 예약서비스에서 결제서비스를 호출할 때 결제서비스 담당 서버 주소를 어떻게 알 수 있을 지 



#### 방법 

1) 설정파일에 서버주소목록을 넣어둔다. 

- 서버목록이 바뀌면 설정파일을 수정해서 재배포해야하는 문제

2) DNS 질의를 이용해서 서버목록을 가져온다. 

- DNS TTL 이슈 존재

3) 서비스 디스커버리를 이용한다.

- 어떤 서비스가 있는 지 알려주는 기능
- 서비스의 접속방법을 알려주는 기능
- 서비스 내의 서버의 추가/제거가 있을 때 이를 알려주는 기능 (서비스의 추가/제거도 마찬가지)
  - 서버사이드 로드밸런싱에서는 로드밸런서의 주소와 포트를
  - 클라이언트사이드 로드밸런싱에서는 해당 서버 목록과 포트를

<br/>

#### 예시 : 결제 서버가 추가된다면?

- 서비스 디스커버리에서 결제 서버들을 지속적으로 헬스체크한다.
- 새로운 결제서버가 추가되면, 추가되면서 서비스 디스커버리에 자신을 알려준다. 
- 추가되면, 서비스 디스커버리가 예약서버에게 결제서비스의 서버 주소들이 변경되었을을 알려준다.
- 예약서버는 결제서비스 목록을 다시 업데이트하고 접속이 가능해진다. 
- 서버 제거의 경우도 동일한 이벤트로 동작한다. 

<br/>

#### 서비스디스커버리로 사용되는 툴들?

- 보통 Coordinator라고 부른다. 
  - Zookeeper
  - Etcd
  - Eureka
  - Consul

- 코디네이터 특징
  - 서비스 가용성이 높다. 
    - 일반적으로 3대 이상으로 동작하고 데이터 동기화가 이루어지므로 절반 이상의 장애가 나지 않는 이상. 서비스 유지 가능
  - 보통은 특정 값을 저장할 수 있는 대쉬보드 역할을 함
    - 이 특성을 이용해서 특정 서비스 군의 서버 목록을 저장
    - 변경되는 값에 대한 Notification이 가능 
  - 노드의 순서를 보장해준다. 
    - 대쉬보드에 쓰인 동일한 순서의 서버목록을 모두가 공유
- 사용 케이스
  - API Server가 추가/변경되었다.
  - Database Master 장비가 추가/변경되었다.
  - Cache 장비가 추가/변경되었다.
- 대응
  - [오래전방식] 목록을 추가하고, 배포해야한다.
  - [현재방식] 목록만 추가하면 알아서 동작한다. (장비만 추가하면 알아서 동작한다) 

<br/>



### Watcher

이벤트가 발생했을 때 등록된 서버 목록이 변경되었다라는 것을 알려줄 수 있는 방식

설정을 바꿔서 재배포하는 방식은 번거롭고 시간이 소요되기 때문에 Watcher 기능을 통해 동적으로 바꿔줄 수 있다. 

Watch하고 있는 서버들에게 해당 값을 바꾸라고 이벤트를 전달해준다. 

```
(참고) Feature Flag
와처를 이용한 방법 중 하나로, 
- 값이 바뀌었을 때 각 서버에 '새로운 기능을 출시/배포'하는 것을 의미 
- 새로운 기능 배포에 문제가 있을 때 이전 버전으로 되돌리는 것을 의미

예) 카카오톡 눈 내리기 기능

신규 피처를 반영했을 때 유용하게 사용
- 배포 시에 문제있으면 피처플래그를 꺼서 해당 기능이 동작안하게 한다.
```

<br/>

### 동적으로 값을 바꾸기 위한 방법

* 값이 바뀌었을 때 각 서버에
  * rest api 등으로 바꾸라고 호출해준다.
  * watcher로 변경되는 값을 통지해주면 서버에서 알아서 바꾸도록 구현하기
  * Spring Cloud Config 사용하기
  * 레디스의 Pub/Sub을 사용할 수도 있음

<br/>

